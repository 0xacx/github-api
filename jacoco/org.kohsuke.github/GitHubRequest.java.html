<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GitHubRequest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GitHub API for Java</a> &gt; <a href="index.source.html" class="el_package">org.kohsuke.github</a> &gt; <span class="el_source">GitHubRequest.java</span></div><h1>GitHubRequest.java</h1><pre class="source lang-java linenums">package org.kohsuke.github;

import edu.umd.cs.findbugs.annotations.NonNull;
import org.apache.commons.lang3.StringUtils;
import org.kohsuke.github.internal.Previews;

import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;

import javax.annotation.CheckForNull;
import javax.annotation.Nonnull;
import javax.annotation.WillClose;

import static java.util.Arrays.asList;

/**
 * Class {@link GitHubRequest} represents an immutable instance used by the client to determine what information to
 * retrieve from a GitHub server. Use the {@link Builder} construct a {@link GitHubRequest}.
 * &lt;p&gt;
 * NOTE: {@link GitHubRequest} should include the data type to be returned. Any use cases where the same request should
 * be used to return different types of data could be handled in some other way. However, the return type is currently
 * not specified until late in the building process, so this is still untyped.
 * &lt;/p&gt;
 */
class GitHubRequest {

<span class="fc" id="L42">    private static final List&lt;String&gt; METHODS_WITHOUT_BODY = asList(&quot;GET&quot;, &quot;DELETE&quot;);</span>
    private final List&lt;Entry&gt; args;
    private final Map&lt;String, String&gt; headers;
    private final Map&lt;String, Object&gt; injectedMappingValues;
    private final String apiUrl;
    private final String urlPath;
    private final String method;
    private final RateLimitTarget rateLimitTarget;
    private final InputStream body;
    private final boolean forceBody;

    private final URL url;

    private GitHubRequest(@Nonnull List&lt;Entry&gt; args,
            @Nonnull Map&lt;String, String&gt; headers,
            @Nonnull Map&lt;String, Object&gt; injectedMappingValues,
            @Nonnull String apiUrl,
            @Nonnull String urlPath,
            @Nonnull String method,
            @Nonnull RateLimitTarget rateLimitTarget,
            @CheckForNull InputStream body,
<span class="fc" id="L63">            boolean forceBody) {</span>
<span class="fc" id="L64">        this.args = Collections.unmodifiableList(new ArrayList&lt;&gt;(args));</span>
<span class="fc" id="L65">        this.headers = Collections.unmodifiableMap(new LinkedHashMap&lt;&gt;(headers));</span>
<span class="fc" id="L66">        this.injectedMappingValues = Collections.unmodifiableMap(new LinkedHashMap&lt;&gt;(injectedMappingValues));</span>
<span class="fc" id="L67">        this.apiUrl = apiUrl;</span>
<span class="fc" id="L68">        this.urlPath = urlPath;</span>
<span class="fc" id="L69">        this.method = method;</span>
<span class="fc" id="L70">        this.rateLimitTarget = rateLimitTarget;</span>
<span class="fc" id="L71">        this.body = body;</span>
<span class="fc" id="L72">        this.forceBody = forceBody;</span>
<span class="fc" id="L73">        String tailApiUrl = buildTailApiUrl();</span>
<span class="fc" id="L74">        url = getApiURL(apiUrl, tailApiUrl);</span>
<span class="fc" id="L75">    }</span>

    /**
     * Create a new {@link Builder}.
     *
     * @return a new {@link Builder}.
     */
    public static Builder&lt;?&gt; newBuilder() {
<span class="fc" id="L83">        return new Builder&lt;&gt;();</span>
    }

    /**
     * Gets the final GitHub API URL.
     *
     * @throws GHException
     *             wrapping a {@link MalformedURLException} if the GitHub API URL cannot be constructed
     */
    @Nonnull
    static URL getApiURL(String apiUrl, String tailApiUrl) {
        try {
<span class="fc bfc" id="L95" title="All 2 branches covered.">            if (!tailApiUrl.startsWith(&quot;/&quot;)) {</span>
<span class="fc" id="L96">                apiUrl = &quot;&quot;;</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">            } else if (&quot;github.com&quot;.equals(apiUrl)) {</span>
                // backward compatibility
<span class="fc" id="L99">                apiUrl = GitHubClient.GITHUB_URL;</span>
            }
<span class="fc" id="L101">            return new URL(apiUrl + tailApiUrl);</span>
<span class="fc" id="L102">        } catch (Exception e) {</span>
            // The data going into constructing this URL should be controlled by the GitHub API framework,
            // so a malformed URL here is a framework runtime error.
            // All callers of this method ended up wrapping and throwing GHException,
            // indicating the functionality should be moved to the common code path.
<span class="fc" id="L107">            throw new GHException(&quot;Unable to build GitHub API URL&quot;, e);</span>
        }
    }

    /**
     * Transform Java Enum into Github constants given its conventions
     *
     * @param en
     *            Enum to be transformed
     * @return a String containing the value of a Github constant
     */
    static String transformEnum(Enum&lt;?&gt; en) {
        // by convention Java constant names are upper cases, but github uses
        // lower-case constants. GitHub also uses '-', which in Java we always
        // replace with '_'
<span class="fc" id="L122">        return en.toString().toLowerCase(Locale.ENGLISH).replace('_', '-');</span>
    }

    /**
     * The method for this request, such as &quot;GET&quot;, &quot;PATCH&quot;, or &quot;DELETE&quot;.
     *
     * @return the request method.
     */
    @Nonnull
    public String method() {
<span class="fc" id="L132">        return method;</span>
    }

    /**
     * The rate limit target for this request.
     *
     * @return the rate limit to use for this request.
     */
    @Nonnull
    public RateLimitTarget rateLimitTarget() {
<span class="fc" id="L142">        return rateLimitTarget;</span>
    }

    /**
     * The arguments for this request. Depending on the {@link #method()} and {@code #inBody()} these maybe added to the
     * url or to the request body.
     *
     * @return the {@link List&lt;Entry&gt;} of arguments
     */
    @Nonnull
    public List&lt;Entry&gt; args() {
<span class="fc" id="L153">        return args;</span>
    }

    /**
     * The headers for this request.
     *
     * @return the {@link Map} of headers
     */
    @Nonnull
    public Map&lt;String, String&gt; headers() {
<span class="fc" id="L163">        return headers;</span>
    }

    /**
     * The headers for this request.
     *
     * @return the {@link Map} of headers
     */
    @Nonnull
    public Map&lt;String, Object&gt; injectedMappingValues() {
<span class="fc" id="L173">        return injectedMappingValues;</span>
    }

    /**
     * The base GitHub API URL for this request represented as a {@link String}
     *
     * @return the url string
     */
    @Nonnull
    public String apiUrl() {
<span class="nc" id="L183">        return apiUrl;</span>
    }

    /**
     * The url path to be added to the {@link #apiUrl()} for this request. If this does not start with a &quot;/&quot;, it instead
     * represents the full url string for this request.
     *
     * @return a url path or full url string
     */
    @Nonnull
    public String urlPath() {
<span class="nc" id="L194">        return urlPath;</span>
    }

    /**
     * The content type to to be sent by this request.
     *
     * @return the content type.
     */
    @Nonnull
    public String contentType() {
<span class="fc" id="L204">        return headers.get(&quot;Content-type&quot;);</span>
    }

    /**
     * The {@link InputStream} to be sent as the body of this request.
     *
     * @return the {@link InputStream}.
     */
    @CheckForNull
    public InputStream body() {
<span class="fc" id="L214">        return body;</span>
    }

    /**
     * The {@link URL} for this request. This is the actual URL the {@link GitHubClient} will send this request to.
     *
     * @return the request {@link URL}
     */
    @Nonnull
    public URL url() {
<span class="fc" id="L224">        return url;</span>
    }

    /**
     * Whether arguments for this request should be included in the URL or in the body of the request.
     *
     * @return true if the arguements should be sent in the body of the request.
     */
    public boolean inBody() {
<span class="fc bfc" id="L233" title="All 4 branches covered.">        return forceBody || !METHODS_WITHOUT_BODY.contains(method);</span>
    }

    /**
     * Create a {@link Builder} from this request. Initial values of the builder will be the same as this
     * {@link GitHubRequest}.
     *
     * @return a {@link Builder} based on this request.
     */
    public Builder&lt;?&gt; toBuilder() {
<span class="fc" id="L243">        return new Builder&lt;&gt;(args,</span>
                headers,
                injectedMappingValues,
                apiUrl,
                urlPath,
                method,
                rateLimitTarget,
                body,
                forceBody);
    }

    private String buildTailApiUrl() {
<span class="fc" id="L255">        String tailApiUrl = urlPath;</span>
<span class="fc bfc" id="L256" title="All 6 branches covered.">        if (!inBody() &amp;&amp; !args.isEmpty() &amp;&amp; tailApiUrl.startsWith(&quot;/&quot;)) {</span>
            try {
<span class="fc" id="L258">                StringBuilder argString = new StringBuilder();</span>
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">                boolean questionMarkFound = tailApiUrl.indexOf('?') != -1;</span>
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">                argString.append(questionMarkFound ? '&amp;' : '?');</span>

<span class="fc bfc" id="L262" title="All 2 branches covered.">                for (Iterator&lt;Entry&gt; it = args.listIterator(); it.hasNext();) {</span>
<span class="fc" id="L263">                    Entry arg = it.next();</span>
<span class="fc" id="L264">                    argString.append(URLEncoder.encode(arg.key, StandardCharsets.UTF_8.name()));</span>
<span class="fc" id="L265">                    argString.append('=');</span>
<span class="fc" id="L266">                    argString.append(URLEncoder.encode(arg.value.toString(), StandardCharsets.UTF_8.name()));</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">                    if (it.hasNext()) {</span>
<span class="fc" id="L268">                        argString.append('&amp;');</span>
                    }
<span class="fc" id="L270">                }</span>
<span class="fc" id="L271">                tailApiUrl += argString;</span>
<span class="nc" id="L272">            } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L273">                throw new GHException(&quot;UTF-8 encoding required&quot;, e);</span>
<span class="fc" id="L274">            }</span>
        }
<span class="fc" id="L276">        return tailApiUrl;</span>
    }

    /**
     * Class {@link Builder} follows the builder pattern for {@link GitHubRequest}.
     *
     * @param &lt;B&gt;
     *            The type of {@link Builder} to return from the various &quot;with*&quot; methods.
     */
    static class Builder&lt;B extends Builder&lt;B&gt;&gt; {

        @Nonnull
        private final List&lt;Entry&gt; args;

        /**
         * The header values for this request.
         */
        @Nonnull
        private final Map&lt;String, String&gt; headers;

        /**
         * Injected local data map
         */
        @Nonnull
        private final Map&lt;String, Object&gt; injectedMappingValues;

        /**
         * The base GitHub API for this request.
         */
        @Nonnull
        private String apiUrl;

        @Nonnull
        private String urlPath;
        /**
         * Request method.
         */
        @Nonnull
        private String method;

        @Nonnull
        private RateLimitTarget rateLimitTarget;

        private InputStream body;
        private boolean forceBody;

        /**
         * Create a new {@link GitHubRequest.Builder}
         */
        protected Builder() {
<span class="fc" id="L326">            this(new ArrayList&lt;&gt;(),</span>
                    new LinkedHashMap&lt;&gt;(),
                    new LinkedHashMap&lt;&gt;(),
                    GitHubClient.GITHUB_URL,
                    &quot;/&quot;,
                    &quot;GET&quot;,
                    RateLimitTarget.CORE,
                    null,
                    false);
<span class="fc" id="L335">        }</span>

        private Builder(@Nonnull List&lt;Entry&gt; args,
                @Nonnull Map&lt;String, String&gt; headers,
                @Nonnull Map&lt;String, Object&gt; injectedMappingValues,
                @Nonnull String apiUrl,
                @Nonnull String urlPath,
                @Nonnull String method,
                @Nonnull RateLimitTarget rateLimitTarget,
                @CheckForNull @WillClose InputStream body,
<span class="fc" id="L345">                boolean forceBody) {</span>
<span class="fc" id="L346">            this.args = new ArrayList&lt;&gt;(args);</span>
<span class="fc" id="L347">            this.headers = new LinkedHashMap&lt;&gt;(headers);</span>
<span class="fc" id="L348">            this.injectedMappingValues = new LinkedHashMap&lt;&gt;(injectedMappingValues);</span>
<span class="fc" id="L349">            this.apiUrl = apiUrl;</span>
<span class="fc" id="L350">            this.urlPath = urlPath;</span>
<span class="fc" id="L351">            this.method = method;</span>
<span class="fc" id="L352">            this.rateLimitTarget = rateLimitTarget;</span>
<span class="fc" id="L353">            this.body = body;</span>
<span class="fc" id="L354">            this.forceBody = forceBody;</span>
<span class="fc" id="L355">        }</span>

        /**
         * Builds a {@link GitHubRequest} from this builder.
         *
         * @return a {@link GitHubRequest}
         * @throws GHException
         *             wrapping a {@link MalformedURLException} if the GitHub API URL cannot be constructed
         */
        public GitHubRequest build() {
<span class="fc" id="L365">            return new GitHubRequest(args,</span>
                    headers,
                    injectedMappingValues,
                    apiUrl,
                    urlPath,
                    method,
                    rateLimitTarget,
                    body,
                    forceBody);
        }

        /**
         * With header requester.
         *
         * @param url
         *            the url
         * @return the request builder
         */
        public B withApiUrl(String url) {
<span class="fc" id="L384">            this.apiUrl = url;</span>
<span class="fc" id="L385">            return (B) this;</span>
        }

        /**
         * Sets the request HTTP header.
         * &lt;p&gt;
         * If a header of the same name is already set, this method overrides it.
         *
         * @param name
         *            the name
         * @param value
         *            the value
         * @return the request builder
         */
        public B setHeader(String name, String value) {
<span class="fc" id="L400">            headers.put(name, value);</span>
<span class="fc" id="L401">            return (B) this;</span>
        }

        /**
         * With header requester.
         *
         * @param name
         *            the name
         * @param value
         *            the value
         * @return the request builder
         */
        public B withHeader(String name, String value) {
<span class="fc" id="L414">            String oldValue = headers.get(name);</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">            if (!StringUtils.isBlank(oldValue)) {</span>
<span class="fc" id="L416">                value = oldValue + &quot;, &quot; + value;</span>
            }
<span class="fc" id="L418">            return setHeader(name, value);</span>
        }

        /**
         * Object to inject into binding.
         *
         * @param value
         *            the value
         * @return the request builder
         */
        public B injectMappingValue(@NonNull Object value) {
<span class="fc" id="L429">            return injectMappingValue(value.getClass().getName(), value);</span>
        }

        /**
         * Object to inject into binding.
         *
         * @param name
         *            the name
         * @param value
         *            the value
         * @return the request builder
         */
        public B injectMappingValue(@NonNull String name, Object value) {
<span class="fc" id="L442">            this.injectedMappingValues.put(name, value);</span>
<span class="fc" id="L443">            return (B) this;</span>
        }

        public B withPreview(String name) {
<span class="fc" id="L447">            return withHeader(&quot;Accept&quot;, name);</span>
        }

        public B withPreview(Previews preview) {
<span class="fc" id="L451">            return withPreview(preview.mediaType());</span>
        }

        /**
         * With requester.
         *
         * @param map
         *            map of key value pairs to add
         * @return the request builder
         */
        public B with(Map&lt;String, Object&gt; map) {
<span class="nc bnc" id="L462" title="All 2 branches missed.">            for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) {</span>
<span class="nc" id="L463">                with(entry.getKey(), entry.getValue());</span>
<span class="nc" id="L464">            }</span>

<span class="nc" id="L466">            return (B) this;</span>
        }

        /**
         * With requester.
         *
         * @param key
         *            the key
         * @param value
         *            the value
         * @return the request builder
         */
        public B with(String key, int value) {
<span class="fc" id="L479">            return with(key, (Object) value);</span>
        }

        /**
         * With requester.
         *
         * @param key
         *            the key
         * @param value
         *            the value
         * @return the request builder
         */
        public B with(String key, long value) {
<span class="fc" id="L492">            return with(key, (Object) value);</span>
        }

        /**
         * With requester.
         *
         * @param key
         *            the key
         * @param value
         *            the value
         * @return the request builder
         */
        public B with(String key, boolean value) {
<span class="fc" id="L505">            return with(key, (Object) value);</span>
        }

        /**
         * With requester.
         *
         * @param key
         *            the key
         * @param e
         *            the e
         * @return the request builder
         */
        public B with(String key, Enum&lt;?&gt; e) {
<span class="fc bfc" id="L518" title="All 2 branches covered.">            if (e == null)</span>
<span class="fc" id="L519">                return with(key, (Object) null);</span>
<span class="fc" id="L520">            return with(key, transformEnum(e));</span>
        }

        /**
         * With requester.
         *
         * @param key
         *            the key
         * @param value
         *            the value
         * @return the request builder
         */
        public B with(String key, String value) {
<span class="fc" id="L533">            return with(key, (Object) value);</span>
        }

        /**
         * With requester.
         *
         * @param key
         *            the key
         * @param value
         *            the value
         * @return the request builder
         */
        public B with(String key, Collection&lt;?&gt; value) {
<span class="fc" id="L546">            return with(key, (Object) value);</span>
        }

        /**
         * With requester.
         *
         * @param key
         *            the key
         * @param value
         *            the value
         * @return the request builder
         */
        public B with(String key, Map&lt;?, ?&gt; value) {
<span class="fc" id="L559">            return with(key, (Object) value);</span>
        }

        /**
         * With requester.
         *
         * @param body
         *            the body
         * @return the request builder
         */
        public B with(@WillClose /* later */ InputStream body) {
<span class="fc" id="L570">            this.body = body;</span>
<span class="fc" id="L571">            return (B) this;</span>
        }

        /**
         * With nullable requester.
         *
         * @param key
         *            the key
         * @param value
         *            the value
         * @return the request builder
         */
        public B withNullable(String key, Object value) {
<span class="fc" id="L584">            args.add(new Entry(key, value));</span>
<span class="fc" id="L585">            return (B) this;</span>
        }

        /**
         * With requester.
         *
         * @param key
         *            the key
         * @param value
         *            the value
         * @return the request builder
         */
        public B with(String key, Object value) {
<span class="fc bfc" id="L598" title="All 2 branches covered.">            if (value != null) {</span>
<span class="fc" id="L599">                args.add(new Entry(key, value));</span>
            }
<span class="fc" id="L601">            return (B) this;</span>
        }

        /**
         * Unlike {@link #with(String, String)}, overrides the existing value
         *
         * @param key
         *            the key
         * @param value
         *            the value
         * @return the request builder
         */
        public B set(String key, Object value) {
<span class="fc" id="L614">            remove(key);</span>
<span class="fc" id="L615">            return with(key, value);</span>

        }

        /**
         * Removes all arg entries for a specific key.
         *
         * @param key
         *            the key
         * @return the request builder
         */
        public B remove(String key) {
<span class="fc bfc" id="L627" title="All 2 branches covered.">            for (int index = 0; index &lt; args.size();) {</span>
<span class="fc bfc" id="L628" title="All 2 branches covered.">                if (args.get(index).key.equals(key)) {</span>
<span class="fc" id="L629">                    args.remove(index);</span>
                } else {
<span class="fc" id="L631">                    index++;</span>
                }
            }
<span class="fc" id="L634">            return (B) this;</span>
        }

        /**
         * Method requester.
         *
         * @param method
         *            the method
         * @return the request builder
         */
        public B method(@Nonnull String method) {
<span class="fc" id="L645">            this.method = method;</span>
<span class="fc" id="L646">            return (B) this;</span>
        }

        /**
         * Method requester.
         *
         * @param rateLimitTarget
         *            the rate limit target for this request. Default is {@link RateLimitTarget#CORE}.
         * @return the request builder
         */
        public B rateLimit(@Nonnull RateLimitTarget rateLimitTarget) {
<span class="fc" id="L657">            this.rateLimitTarget = rateLimitTarget;</span>
<span class="fc" id="L658">            return (B) this;</span>
        }

        /**
         * Content type requester.
         *
         * @param contentType
         *            the content type
         * @return the request builder
         */
        public B contentType(String contentType) {
<span class="fc" id="L669">            this.headers.put(&quot;Content-type&quot;, contentType);</span>
<span class="fc" id="L670">            return (B) this;</span>
        }

        /**
         * NOT FOR PUBLIC USE. Do not make this method public.
         * &lt;p&gt;
         * Sets the path component of api URL without URI encoding.
         * &lt;p&gt;
         * Should only be used when passing a literal URL field from a GHObject, such as {@link GHContent#refresh()} or
         * when needing to set query parameters on requests methods that don't usually have them, such as
         * {@link GHRelease#uploadAsset(String, InputStream, String)}.
         *
         * @param rawUrlPath
         *            the content type
         * @return the request builder
         */
        B setRawUrlPath(@Nonnull String rawUrlPath) {
<span class="fc" id="L687">            Objects.requireNonNull(rawUrlPath);</span>
            // This method should only work for full urls, which must start with &quot;http&quot;
<span class="fc bfc" id="L689" title="All 2 branches covered.">            if (!rawUrlPath.startsWith(&quot;http&quot;)) {</span>
<span class="fc" id="L690">                throw new GHException(&quot;Raw URL must start with 'http'&quot;);</span>
            }
<span class="fc" id="L692">            this.urlPath = rawUrlPath;</span>
<span class="fc" id="L693">            return (B) this;</span>
        }

        /**
         * Path component of api URL. Appended to api url.
         * &lt;p&gt;
         * If urlPath starts with a slash, it will be URI encoded as a path. If it starts with anything else, it will be
         * used as is.
         *
         * @param urlPathItems
         *            the content type
         * @return the request builder
         */
        public B withUrlPath(@Nonnull String urlPath, @Nonnull String... urlPathItems) {
            // full url may be set and reset as needed
<span class="fc bfc" id="L708" title="All 4 branches covered.">            if (urlPathItems.length == 0 &amp;&amp; !urlPath.startsWith(&quot;/&quot;)) {</span>
<span class="fc" id="L709">                return setRawUrlPath(urlPath);</span>
            }

            // Once full url is set, do not allow path setting
<span class="pc bpc" id="L713" title="1 of 2 branches missed.">            if (!this.urlPath.startsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L714">                throw new GHException(&quot;Cannot append to url path after setting a full url&quot;);</span>
            }

<span class="fc" id="L717">            String tailUrlPath = urlPath;</span>
<span class="fc bfc" id="L718" title="All 2 branches covered.">            if (urlPathItems.length != 0) {</span>
<span class="fc" id="L719">                tailUrlPath += &quot;/&quot; + String.join(&quot;/&quot;, urlPathItems);</span>
            }

<span class="fc" id="L722">            tailUrlPath = StringUtils.prependIfMissing(tailUrlPath, &quot;/&quot;);</span>

<span class="fc" id="L724">            this.urlPath = urlPathEncode(tailUrlPath);</span>
<span class="fc" id="L725">            return (B) this;</span>
        }

        /**
         * Small number of GitHub APIs use HTTP methods somewhat inconsistently, and use a body where it's not expected.
         * Normally whether parameters go as query parameters or a body depends on the HTTP verb in use, but this method
         * forces the parameters to be sent as a body.
         *
         * @return the request builder
         */
        public B inBody() {
<span class="fc" id="L736">            forceBody = true;</span>
<span class="fc" id="L737">            return (B) this;</span>
        }
    }

    protected static class Entry {
        final String key;
        final Object value;

<span class="fc" id="L745">        protected Entry(String key, Object value) {</span>
<span class="fc" id="L746">            this.key = key;</span>
<span class="fc" id="L747">            this.value = value;</span>
<span class="fc" id="L748">        }</span>
    }

    /**
     * Encode the path to url safe string.
     *
     * @param value
     *            string to be path encoded.
     * @return The encoded string.
     */
    private static String urlPathEncode(String value) {
        try {
<span class="fc" id="L760">            return new URI(null, null, value, null, null).toASCIIString();</span>
<span class="nc" id="L761">        } catch (URISyntaxException ex) {</span>
<span class="nc" id="L762">            throw new AssertionError(ex);</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>
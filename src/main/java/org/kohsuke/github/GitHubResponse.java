package org.kohsuke.github;

import org.apache.commons.io.IOUtils;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Field;
import java.net.HttpURLConnection;
import java.net.ProtocolException;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.zip.GZIPInputStream;

import javax.annotation.CheckForNull;
import javax.annotation.Nonnull;

import static org.apache.commons.lang3.StringUtils.defaultString;

/**
 * A GitHubResponse
 * <p>
 * A {@link GitHubResponse} generated by from sending a {@link GitHubRequest} to a {@link GitHubClient}.
 * </p>
 *
 * @param <T>
 *            the type of the data parsed from the body of a {@link ResponseInfo}.
 */
class GitHubResponse<T> {

    private final int statusCode;

    @Nonnull
    private final GitHubRequest request;

    @Nonnull
    private final Map<String, List<String>> headers;

    @CheckForNull
    private final T body;

    GitHubResponse(GitHubResponse<T> response, @CheckForNull T body) {
        this.statusCode = response.statusCode();
        this.request = response.request();
        this.headers = response.headers();
        this.body = body;
    }

    GitHubResponse(ResponseInfo responseInfo, @CheckForNull T body) {
        this.statusCode = responseInfo.statusCode();
        this.request = responseInfo.request();
        this.headers = responseInfo.headers();
        this.body = body;
    }

    /**
     * The {@link URL} for this response.
     *
     * @return the {@link URL} for this response.
     */
    @Nonnull
    public URL url() {
        return request.url();
    }

    /**
     * The {@link GitHubRequest} for this response.
     *
     * @return the {@link GitHubRequest} for this response.
     */
    @Nonnull
    public GitHubRequest request() {
        return request;
    }

    /**
     * The status code for this response.
     *
     * @return the status code for this response.
     */
    public int statusCode() {
        return statusCode;
    }

    /**
     * The headers for this response.
     *
     * @return the headers for this response.
     */
    @Nonnull
    public Map<String, List<String>> headers() {
        return headers;
    }

    /**
     * Gets the value of a header field for this response.
     *
     * @param name
     *            the name of the header field.
     * @return the value of the header field, or {@code null} if the header isn't set.
     */
    @CheckForNull
    public String headerField(String name) {
        String result = null;
        if (headers.containsKey(name)) {
            result = headers.get(name).get(0);
        }
        return result;
    }

    /**
     * The body of the response parsed as a {@link T}
     *
     * @return body of the response
     */
    public T body() {
        return body;
    }

    /**
     * Represents a supplier of results that can throw.
     *
     * <p>
     * This is a <a href="package-summary.html">functional interface</a> whose functional method is
     * {@link #apply(ResponseInfo)}.
     *
     * @param <T>
     *            the type of results supplied by this supplier
     */
    @FunctionalInterface
    interface BodyHandler<T> {

        /**
         * Gets a result.
         *
         * @return a result
         * @throws IOException
         *             if an I/O Exception occurs.
         */
        T apply(ResponseInfo input) throws IOException;
    }

    /**
     * Initial response information supplied to a {@link BodyHandler} when a response is initially received and before
     * the body is processed.
     */
    static abstract class ResponseInfo {

        private final int statusCode;
        @Nonnull
        private final GitHubRequest request;
        @Nonnull
        private final Map<String, List<String>> headers;

        /**
         * Opens a connection using a {@link GitHubClient} and retrieves a {@link ResponseInfo} from a
         * {@link HttpURLConnection}.
         *
         * @param client
         *            the client to query.
         * @param request
         *            the request to send.
         * @return the initial {@link ResponseInfo}.
         * @throws IOException
         *             if an I/O Exception occurs.
         */
        @Nonnull
        static ResponseInfo fromHttpURLConnection(@Nonnull GitHubClient client, @Nonnull GitHubRequest request)
                throws IOException {
            HttpURLConnection connection;
            try {
                connection = HttpURLConnectionResponseInfo.setupConnection(client, request);
            } catch (IOException e) {
                // An error in here should be wrapped to bypass http exception wrapping.
                throw new GHIOException(e.getMessage(), e);
            }

            // HttpUrlConnection is nuts. This call opens the connection and gets a response.
            // Putting this on it's own line for ease of debugging if needed.
            int statusCode = connection.getResponseCode();
            Map<String, List<String>> headers = connection.getHeaderFields();

            return new HttpURLConnectionResponseInfo(request, statusCode, headers, connection);
        }

        protected ResponseInfo(@Nonnull GitHubRequest request,
                int statusCode,
                @Nonnull Map<String, List<String>> headers) {
            this.request = request;
            this.statusCode = statusCode;
            this.headers = Collections.unmodifiableMap(new HashMap<>(headers));
        }

        /**
         * Gets the value of a header field for this response.
         *
         * @param name
         *            the name of the header field.
         * @return the value of the header field, or {@code null} if the header isn't set.
         */
        @CheckForNull
        public String headerField(String name) {
            String result = null;
            if (headers.containsKey(name)) {
                result = headers.get(name).get(0);
            }
            return result;
        }

        /**
         * The response body as an {@link InputStream}.
         *
         * @return the response body
         * @throws IOException
         *             if an I/O Exception occurs.
         */
        abstract InputStream bodyStream() throws IOException;

        /**
         * The error message for this response.
         *
         * @return if there is an error with some error string, that is returned. If not, {@code null}.
         */
        abstract String errorMessage();

        /**
         * The {@link URL} for this response.
         *
         * @return the {@link URL} for this response.
         */
        @Nonnull
        public URL url() {
            return request.url();
        }

        /**
         * Gets the {@link GitHubRequest} for this response.
         *
         * @return the {@link GitHubRequest} for this response.
         */
        @Nonnull
        public GitHubRequest request() {
            return request;
        }

        /**
         * The status code for this response.
         *
         * @return the status code for this response.
         */
        public int statusCode() {
            return statusCode;
        }

        /**
         * The headers for this response.
         *
         * @return the headers for this response.
         */
        @Nonnull
        public Map<String, List<String>> headers() {
            return headers;
        }

        /**
         * Gets the body of the response as a {@link String}.
         *
         * @return the body of the response as a {@link String}.F
         * @throws IOException
         *             if an I/O Exception occurs.
         */
        String getBodyAsString() throws IOException {
            InputStreamReader r = null;
            try {
                r = new InputStreamReader(this.bodyStream(), StandardCharsets.UTF_8);
                return IOUtils.toString(r);
            } finally {
                IOUtils.closeQuietly(r);
            }

        }
    }

    /**
     * Initial response information supplied to a {@link BodyHandler} when a response is initially received and before
     * the body is processed.
     *
     * Implementation specific to {@link HttpURLConnection}.
     */
    static class HttpURLConnectionResponseInfo extends ResponseInfo {

        @Nonnull
        final HttpURLConnection connection;

        private HttpURLConnectionResponseInfo(@Nonnull GitHubRequest request,
                int statusCode,
                @Nonnull Map<String, List<String>> headers,
                @Nonnull HttpURLConnection connection) {
            super(request, statusCode, headers);
            this.connection = connection;
        }

        @Nonnull
        static HttpURLConnection setupConnection(@Nonnull GitHubClient client, @Nonnull GitHubRequest request)
                throws IOException {
            HttpURLConnection connection = client.getConnector().connect(request.url());

            // if the authentication is needed but no credential is given, try it anyway (so that some calls
            // that do work with anonymous access in the reduced form should still work.)
            if (client.encodedAuthorization != null)
                connection.setRequestProperty("Authorization", client.encodedAuthorization);

            setRequestMethod(request.method(), connection);
            buildRequest(request, connection);

            return connection;
        }

        /**
         * Set up the request parameters or POST payload.
         */
        private static void buildRequest(GitHubRequest request, HttpURLConnection connection) throws IOException {
            for (Map.Entry<String, String> e : request.headers().entrySet()) {
                String v = e.getValue();
                if (v != null)
                    connection.setRequestProperty(e.getKey(), v);
            }
            connection.setRequestProperty("Accept-Encoding", "gzip");

            if (request.inBody()) {
                connection.setDoOutput(true);

                try (InputStream body = request.body()) {
                    if (body != null) {
                        connection.setRequestProperty("Content-type",
                                defaultString(request.contentType(), "application/x-www-form-urlencoded"));
                        byte[] bytes = new byte[32768];
                        int read;
                        while ((read = body.read(bytes)) != -1) {
                            connection.getOutputStream().write(bytes, 0, read);
                        }
                    } else {
                        connection.setRequestProperty("Content-type",
                                defaultString(request.contentType(), "application/json"));
                        Map<String, Object> json = new HashMap<>();
                        for (GitHubRequest.Entry e : request.args()) {
                            json.put(e.key, e.value);
                        }
                        GitHubClient.MAPPER.writeValue(connection.getOutputStream(), json);
                    }
                }
            }
        }

        private static void setRequestMethod(String method, HttpURLConnection connection) throws IOException {
            try {
                connection.setRequestMethod(method);
            } catch (ProtocolException e) {
                // JDK only allows one of the fixed set of verbs. Try to override that
                try {
                    Field $method = HttpURLConnection.class.getDeclaredField("method");
                    $method.setAccessible(true);
                    $method.set(connection, method);
                } catch (Exception x) {
                    throw (IOException) new IOException("Failed to set the custom verb").initCause(x);
                }
                // sun.net.www.protocol.https.DelegatingHttpsURLConnection delegates to another HttpURLConnection
                try {
                    Field $delegate = connection.getClass().getDeclaredField("delegate");
                    $delegate.setAccessible(true);
                    Object delegate = $delegate.get(connection);
                    if (delegate instanceof HttpURLConnection) {
                        HttpURLConnection nested = (HttpURLConnection) delegate;
                        setRequestMethod(method, nested);
                    }
                } catch (NoSuchFieldException x) {
                    // no problem
                } catch (IllegalAccessException x) {
                    throw (IOException) new IOException("Failed to set the custom verb").initCause(x);
                }
            }
            if (!connection.getRequestMethod().equals(method))
                throw new IllegalStateException("Failed to set the request method to " + method);
        }

        /**
         * {@inheritDoc}
         */
        InputStream bodyStream() throws IOException {
            return wrapStream(connection.getInputStream());
        }

        /**
         * {@inheritDoc}
         */
        String errorMessage() {
            String result = null;
            InputStream stream = null;
            try {
                stream = connection.getErrorStream();
                if (stream != null) {
                    result = IOUtils.toString(wrapStream(stream), StandardCharsets.UTF_8);
                }
            } catch (Exception e) {
                LOGGER.log(Level.FINER, "Ignored exception get error message", e);
            } finally {
                IOUtils.closeQuietly(stream);
            }
            return result;
        }

        /**
         * Handles the "Content-Encoding" header.
         *
         * @param stream
         *            the stream to possibly wrap
         *
         */
        private InputStream wrapStream(InputStream stream) throws IOException {
            String encoding = headerField("Content-Encoding");
            if (encoding == null || stream == null)
                return stream;
            if (encoding.equals("gzip"))
                return new GZIPInputStream(stream);

            throw new UnsupportedOperationException("Unexpected Content-Encoding: " + encoding);
        }

        private static final Logger LOGGER = Logger.getLogger(GitHubClient.class.getName());

    }
}
